# 위젯 소개 (Introduction to widgets)

`위젯(Widget)`은 React에서 영감을 얻은 모던 프레임워크를 기반으로 개발되었습니다. 핵심 아이디어는 위젯에서 UI를 구성한다는 것입니다. 위젯은 현재 구성 및 상태에 따라 렌더링을 어떻게 해야하는지에 대한 description을 가지고 있습니다. 위젯의 상태가 변경되면 위젯은 description을 다시 빌드(rebuild)합니다. 이 description은 render tree에서의 최소한의 변화를 위한 비교 로직에서 사용됩니다.

> Note: 코드를 통해 Flutter에 더 익숙해지고 싶다면 [기본 레이아웃 코드랩](https://docs.flutter.dev/codelabs/layout-basics), [레이아웃 빌드](https://docs.flutter.dev/ui/layout), 그리고 [Flutter 앱에 상호작용 추가](https://docs.flutter.dev/ui/interactive) 를 확인해보세요.

## Hello world
기본적인 Flutter 앱은 단순히 위젯으로 `runApp()` 함수를 호출합니다.

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(
    const Center(
      child: Text(
        'Hello, world!',
        textDirection: TextDirection.ltr,
      ),
    ),
  );
}
```

`runApp()` 함수는 주어진 [Widget](https://api.flutter.dev/flutter/widgets/Widget-class.html) 을 가져와 위젯 트리의 root로 만듭니다. 위 예시에서 위젯 트리는 [Center](https://api.flutter.dev/flutter/widgets/Center-class.html) 위젯과 Center 위젯의 child인 [Text](https://api.flutter.dev/flutter/widgets/Text-class.html) 위젯으로 구성됩니다. 프레임워크는 root 위젯이 화면을 덮도록(cover) 강제하며, 이것은 "Hello, world" 라는 텍스트가 화면 중앙에 표시된다는 것을 의미합니다. 이 경우 텍스트 방향을 지정해야 합니다. 나중에 설명하겠지만, `MaterialApp` 위젯을 사용하면 이 작업이 수행됩니다.

앱을 작성할 때 일반적으로 위젯이 상태를 관리하는지 여부에 따라 [StatelessWidget](https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html) 또는 [StatefulWidget](https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html) 의 서브클래스인 위젯을 정의합니다. 위젯의 주요 작업은 다른 하위 수준 위젯의 관점에서 위젯을 설명(describe)하는 [build()](https://api.flutter.dev/flutter/widgets/StatelessWidget/build.html) 함수를 구현하는 것입니다. 프레임워크는 위젯의 geometry를 계산하고 설명하는 [RenderObject](https://api.flutter.dev/flutter/rendering/RenderObject-class.html)를 나타내는 위젯에서 프로세스가 끝날 때까지 해당 위젯을 빌드합니다.

## 기본 위젯 (Basic Widgets)
Flutter는 다음곽 같이 일반적으로 사용되는 강력한 기본 위젯들을 제공합니다.

- [Text](https://api.flutter.dev/flutter/widgets/Text-class.html) : `Text` 위젯을 사용하면 어플리케이션에 스타일이 지정된 텍스트를 추가할 수 있습니다.
- [Row](https://api.flutter.dev/flutter/widgets/Row-class.html), [Column](https://api.flutter.dev/flutter/widgets/Column-class.html) : 이런 플렉스 위젯(flex widget)을 사용하면 가로(`Row`) 및 세로(`Column`) 방향에 대한 유연한 레이아웃을 만들 수 있습니다. 이런 객체의 디자인은 웹의 `flexbox` 레이아웃 모델을 기반으로 합니다.
- [Stack](https://api.flutter.dev/flutter/widgets/Stack-class.html) : `Stack` 위젯을 사용하면 위젯을 위에 덮어서 배치할 수 있습니다. `Stack` 위젯의 children 위젯들은 `top`, `right`, `bottom`, `left`를 기준으로 위치를 지정할 수 있습니다. 스택은 웹의 `absolute positioning` 레이아웃 모델을 기반으로 합니다.
- [Container](https://api.flutter.dev/flutter/widgets/Container-class.html) : `Container` 위젯을 사용하면 직사각형 시각적 요소를 만들 수 있습니다. 컨테이너는 배경, 테두리 또는 그림자와 같은 [BoxDecoration](https://api.flutter.dev/flutter/painting/BoxDecoration-class.html)으로 꾸밀 수 있습니다. 컨테이너에는 size에 적용되는 margin, padding 및 제약조건이 있을 수 있습니다. 또한 컨테이너는 행렬을 사용하여 3차원 공간에서 변형될 수 있습니디ㅏ.

```dart
import 'package:flutter/material.dart';

class MyAppBar extends StatelessWidget {
  const MyAppBar({required this.title, super.key});

  // Fields in a Widget subclass are always marked "final".

  final Widget title;

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 56, // in logical pixels
      padding: const EdgeInsets.symmetric(horizontal: 8),
      decoration: BoxDecoration(color: Colors.blue[500]),
      // Row is a horizontal, linear layout.
      child: Row(
        children: [
          const IconButton(
            icon: Icon(Icons.menu),
            tooltip: 'Navigation menu',
            onPressed: null, // null disables the button
          ),
          // Expanded expands its child
          // to fill the available space.
          Expanded(
            child: title,
          ),
          const IconButton(
            icon: Icon(Icons.search),
            tooltip: 'Search',
            onPressed: null,
          ),
        ],
      ),
    );
  }
}

class MyScaffold extends StatelessWidget {
  const MyScaffold({super.key});

  @override
  Widget build(BuildContext context) {
    // Material is a conceptual piece
    // of paper on which the UI appears.
    return Material(
      // Column is a vertical, linear layout.
      child: Column(
        children: [
          MyAppBar(
            title: Text(
              'Example title',
              style: Theme.of(context) //
                  .primaryTextTheme
                  .titleLarge,
            ),
          ),
          const Expanded(
            child: Center(
              child: Text('Hello, world!'),
            ),
          ),
        ],
      ),
    );
  }
}

void main() {
  runApp(
    const MaterialApp(
      title: 'My app', // used by the OS task switcher
      home: SafeArea(
        child: MyScaffold(),
      ),
    ),
  );
}
```

`pubspec.yaml` 파일의 `flutter` 섹션에 `uses-material-design: true` 항목이 있는지 확인하세요. 사전 정의된 [Material icons](https://design.google.com/icons/) 셋을 사용할 수 있습니다. 일반적으로 Materials 라이브러리를 사용하는 경우 이 라인을 포함하는 것이 좋습니다.

```yaml
name: my_app
flutter:
  uses-material-design: true
```

테마 데이터를 상속하려면 많은 Material Design 위젯이 제대로 표시되도록 [MaterialApp](https://api.flutter.dev/flutter/material/MaterialApp-class.html) 내부에 있어야 합니다. 따라서, `MaterialApp` 으로 애플리케이션을 실행하세요.

`MyAppBar` 위젯은 장치독립적인 높이 56픽셀, 좌우 내부 padding 8픽셀이 있는 [Container](https://api.flutter.dev/flutter/widgets/Container-class.html)를 만듭니다. 컨테이너 내에서 `MyAppBar`는 [Row](https://api.flutter.dev/flutter/widgets/Row-class.html) 레이아웃을 사용해서 children을 구성합니다. 중간 child인 `title` 위젯은 [Expanded](https://api.flutter.dev/flutter/widgets/Expanded-class.html)로 표시됩니다. 즉, 확장되어서 다른 children이 사용하지 않은 나머지 공간을 채웁니다. `Expanded` children을 여러 개 가질 수 있으며 `Expanded`의 [flex](https://api.flutter.dev/flutter/widgets/Expanded-class.html#flex) 속성을 사용해서 차지하는 공간에 대한 비율을 정의할 수 있습니다.

`MyScaffold` 위젯은 수직 column으로 children을 구성합니다. column 맨 위에 `MyAppBar` 인스턴스를 배치하고, 제목으로 사용할 [Text](https://api.flutter.dev/flutter/widgets/Text-class.html) 위젯을 앱 바(app bar)에 전달합니다. 위젯을 다른 위젯에 인수로 전달하는 것은 재사용성이 있는 위젯을 정의할 수 있는 강력한 방법입니다. 마지막으로, `MyScaffold`는 [Expanded](https://api.flutter.dev/flutter/widgets/Expanded-class.html)를 사용해서 중앙 메세지를 포함된 body로 나머지 공간을 채웁니다.

자세한 내용은 [Layouts](https://docs.flutter.dev/ui/widgets/layout)를 참고하세요.

## Material 컴포넌트 사용하기 (Using Material Components)
Flutter는 Material Design을 따르는 앱을 빌드하는 데 도움이 되는 다양한 위젯을 제공합니다. Material 앱은 [MaterialApp](https://api.flutter.dev/flutter/material/MaterialApp-class.html) 위젯으로 시작합니다. 이 위젯은 [Navigator](https://api.flutter.dev/flutter/widgets/Navigator-class.html)를 포함한 여러 유용한 위젯을 빌드합니다. `Navigator`는 문자열로 식별되는 `routes` 라는 위젯 스택을 관리합니다. `Navigator`를 사용하면 어플리케이션 화면 간 이동을 할 수 있습니다. [MaterialApp](https://api.flutter.dev/flutter/material/MaterialApp-class.html) 위젯을 사용하는 것은 선택사항이지만 좋은 선택이 될 수 있습니다.

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(
    const MaterialApp(
      title: 'Flutter Tutorial',
      home: TutorialHome(),
    ),
  );
}

class TutorialHome extends StatelessWidget {
  const TutorialHome({super.key});

  @override
  Widget build(BuildContext context) {
    // Scaffold is a layout for
    // the major Material Components.
    return Scaffold(
      appBar: AppBar(
        leading: const IconButton(
          icon: Icon(Icons.menu),
          tooltip: 'Navigation menu',
          onPressed: null,
        ),
        title: const Text('Example title'),
        actions: const [
          IconButton(
            icon: Icon(Icons.search),
            tooltip: 'Search',
            onPressed: null,
          ),
        ],
      ),
      // body is the majority of the screen.
      body: const Center(
        child: Text('Hello, world!'),
      ),
      floatingActionButton: const FloatingActionButton(
        tooltip: 'Add', // used by assistive technologies
        onPressed: null,
        child: Icon(Icons.add),
      ),
    );
  }
}
```

이제 코드가 `MyAppBar` 및 `MyScaffold`에서 [AppBar](https://api.flutter.dev/flutter/material/AppBar-class.html) 및 [Scaffold](https://api.flutter.dev/flutter/material/Scaffold-class.html) 위젯으로 변경되었으므로 앱이 좀 더 Material스럽게 보입니다. 예를 들어, 앱 바(app bar)에는 그림자가 있고 제목 텍스트는 올바른 스타일을 지동으로 상속합니다. 플로팅 버튼도 추가됩니다.

위젯은 다른 위젯에 인수로 전달됩니다. [Scaffold](https://api.flutter.dev/flutter/material/Scaffold-class.html) 위젯은 명명된 인수로 다양한 위젯을 사용하며, 각 위젯은 `Scaffold` 레이아웃의 적절한 위치에 배치됩니다. 마찬가지로 `AppBar` 위젯을 사용하면 선행([leading](https://api.flutter.dev/flutter/material/AppBar-class.html#leading)) 위젯에 대한 위젯과 [title](https://api.flutter.dev/flutter/material/AppBar-class.html#title) 위젯의 [actions](https://api.flutter.dev/flutter/material/AppBar-class.html#actions)를 전달할 수 있습니다. 이 패턴은 프레임워크 전체에 적용되며, 커스텀 위젯을 디자인할 때 고려할 수 있는 패턴입니다.

자세한 내용은 [Material Components widgets](https://docs.flutter.dev/ui/widgets/material)를 참고하세요.

> Note: Material은 Flutter에 포함된 번들 디자인 2가지 중 하나입니다. iOS 위주 디자인을 만들기 위해서는 자체 버전의 [CupertinoApp](https://api.flutter.dev/flutter/cupertino/CupertinoApp-class.html) 및 [CupertinoNavigationBar](https://api.flutter.dev/flutter/cupertino/CupertinoNavigationBar-class.html)가 있는 [Cupertino components](https://docs.flutter.dev/ui/widgets/cupertino) 패키지를 참고하세요.

## 제스처 다루기 (Handling gestures)
대부분의 어플리케이션에는 시스템과의 사용자 상호작용 폼(user interaction form)이 있습니다. 대화형 어플리케이션 구축의 첫 번째 단계는 입력 제스처를 감지하는 것입니다. 간단한 버튼을 만들어서 어떻게 작동하는지 확인해보세요.

```dart
import 'package:flutter/material.dart';

class MyButton extends StatelessWidget {
  const MyButton({super.key});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        print('MyButton was tapped!');
      },
      child: Container(
        height: 50,
        padding: const EdgeInsets.all(8),
        margin: const EdgeInsets.symmetric(horizontal: 8),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(5),
          color: Colors.lightGreen[500],
        ),
        child: const Center(
          child: Text('Engage'),
        ),
      ),
    );
  }
}

void main() {
  runApp(
    const MaterialApp(
      home: Scaffold(
        body: Center(
          child: MyButton(),
        ),
      ),
    ),
  );
}
```

[GestureDetector](https://api.flutter.dev/flutter/widgets/GestureDetector-class.html) 위젯은 시각적으로 표시하는 기능은 없지만, 대신에 사용자의 제스처를 감지합니다. 사용자가 [Container](https://api.flutter.dev/flutter/widgets/Container-class.html)를 탭하면 `GestureDetector`가 [onTap()](https://api.flutter.dev/flutter/widgets/GestureDetector-class.html#onTap) callback을 호출하고, 위 코드의 경우 콘솔에 메세지를 출력합니다. `GestureDetector`를 사용해서 탭, 드래그, 줌 인/아웃 등 다양한 입력 제스처를 감지할 수 있습니다.

많은 위젯이 [GestureDetector](https://api.flutter.dev/flutter/widgets/GestureDetector-class.html)를 사용해서 다른 위젯에 대한 선택적 콜백을 제공합니다. 예를 들어, [IconButton](https://api.flutter.dev/flutter/material/IconButton-class.html), [ElebatedButton](https://api.flutter.dev/flutter/material/ElevatedButton-class.html) 및 [FloatingActionButton](https://api.flutter.dev/flutter/material/FloatingActionButton-class.html) 위젯에는 사용자가 위젯을 누를 때 실행되는 [onPressed()](https://api.flutter.dev/flutter/material/ElevatedButton-class.html#onPressed) 콜백이 있습니다.

자세한 내용은 [Gestures in Flutter](https://docs.flutter.dev/ui/advanced/gestures)를 참고하세요.

## 입력 응답으로 위젯 변경하기 (Changing widgets in response to input)
지금까지 stateless 위젯만 사용했습니다. Stateless 위젯은 parent 위젯에서 인수를 받아 [final](https://dart.dev/language/variables#final-and-const) 멤버 번수에 저장합니다. 위젯이 [build()](https://api.flutter.dev/flutter/widgets/StatelessWidget/build.html)를 요청하면 이 저장된 값을 사용해서 생성하는 위젯에 대한 새 인수를 도출합니다.

보다 복잡한 경험(예: 사용자 입력에 대한 반응)을 구현하기 위해 어플리케이션은 일반적으로 일부 상태(state)를 전달합니다. Flutter는 `StatefulWidgets`를 사용해서 이 개념을 구현합니다. `StatefulWidgets`는 state를 유지하는 데 사용되는 `State` 객체를 생성하는 방법을 가지고 있는 특수 위젯입니다. 위에서 언급한 [ElevatedButton](https://api.flutter.dev/flutter/material/ElevatedButton-class.html)을 사용하는 아래의 예제를 참고하세요.

```dart
import 'package:flutter/material.dart';

class Counter extends StatefulWidget {
  // This class is the configuration for the state.
  // It holds the values (in this case nothing) provided
  // by the parent and used by the build  method of the
  // State. Fields in a Widget subclass are always marked
  // "final".

  const Counter({super.key});

  @override
  State<Counter> createState() => _CounterState();
}

class _CounterState extends State<Counter> {
  int _counter = 0;

  void _increment() {
    setState(() {
      // This call to setState tells the Flutter framework
      // that something has changed in this State, which
      // causes it to rerun the build method below so that
      // the display can reflect the updated values. If you
      // change _counter without calling setState(), then
      // the build method won't be called again, and so
      // nothing would appear to happen.
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    // This method is rerun every time setState is called,
    // for instance, as done by the _increment method above.
    // The Flutter framework has been optimized to make
    // rerunning build methods fast, so that you can just
    // rebuild anything that needs updating rather than
    // having to individually changes instances of widgets.
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: <Widget>[
        ElevatedButton(
          onPressed: _increment,
          child: const Text('Increment'),
        ),
        const SizedBox(width: 16),
        Text('Count: $_counter'),
      ],
    );
  }
}

void main() {
  runApp(
    const MaterialApp(
      home: Scaffold(
        body: Center(
          child: Counter(),
        ),
      ),
    ),
  );
}
```

`StatefulWidget`과 `State`가 왜 별개의 객체인지 궁금할 수 있습니다. Flutter에서 이 두 객체는 생명주기(life cycle)가 다릅니다. `Widgets`는 현재 state에서 어플리케이션의 화면을 구성하는 데 사용되는 임시 객체입니다. 반면에 `State` 객체는 `build()` 호출 간에 유지되므로 정보를 기억할 수 있습니다.

위 예시는 사용자 입력을 받아서 `build()` 메서드에서 결과를 바로 사용합니다. 더 복잡한 어플리케이션에서는 위젯 계층 구조(hierarchy)의 다른 부분이 다른 문제를 담당할 수 있습니다. 예를 들어, 한 위젯은 날짜나 위치와 같은 특정 정보를 수집할 목적으로 사용자 인터페이스를 제공하고 다른 위젯은 해당 정보를 사용해서 표시(presentation)할 수 있습니다.

Flutter에서 변경 알림(change notifications)은 콜백을 통해 위젯 계층 구조 안에서 "위로" 흐르고 현재 state는 presentation을 수행하는 stateless 위젯 방향인 "아래로" 흐릅니다. 이 흐름을 중개하는 공통 parent는 `State` 입니다. 다음 예시는 이것이 실제로 어떻게 동작하는지 보여줍니다.

```dart
import 'package:flutter/material.dart';

class CounterDisplay extends StatelessWidget {
  const CounterDisplay({required this.count, super.key});

  final int count;

  @override
  Widget build(BuildContext context) {
    return Text('Count: $count');
  }
}

class CounterIncrementor extends StatelessWidget {
  const CounterIncrementor({required this.onPressed, super.key});

  final VoidCallback onPressed;

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: onPressed,
      child: const Text('Increment'),
    );
  }
}

class Counter extends StatefulWidget {
  const Counter({super.key});

  @override
  State<Counter> createState() => _CounterState();
}

class _CounterState extends State<Counter> {
  int _counter = 0;

  void _increment() {
    setState(() {
      ++_counter;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: <Widget>[
        CounterIncrementor(onPressed: _increment),
        const SizedBox(width: 16),
        CounterDisplay(count: _counter),
      ],
    );
  }
}

void main() {
  runApp(
    const MaterialApp(
      home: Scaffold(
        body: Center(
          child: Counter(),
        ),
      ),
    ),
  );
}
```

카운터를 표시하는 기능(`CounterDisplay`)과 카운터를 변경하는 기능(`CounterIncrementor`)을 깔끔하게 분리하는 두 개의 새로운 stateless 위젯 생성에 주목하세요. 최종 결과는 이전 예시와 동일하지만 책임을 분리하면 parent에서 단순성을 유지하면서 각 위젯에서 더 큰 복잡성을 캡슐화(encapsulate)할 수 있습니다.

자세한 내용은 다음을 참고하세요.

- [StatefulWidget](https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html)
- [setState()](https://api.flutter.dev/flutter/widgets/State/setState.html)
